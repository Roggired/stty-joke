# Stty Joke by Mr.Kefir

Эксперимент с утилитой stty UNIX систем.

Цель сего безобразия - научиться отключать буферизацию ввода в терминалах UNIX систем, чтобы реализовать 
побайтовое чтение стандартного ввода. Программа должна получать ввод СРАЗУ как только пользователь 
нажал клавишу на клавиатуре. Стандратное поведение терминала - ожидание, пока пользователь не нажмет 
клавишу enter.

Стандартное поведение терминала можно упрощенно представить так:  

1. Нажатие клавиши  
2. Код символа отправляется в буфер терминала  
3. Если нажата клавиша enter, то данные из буфера отправляются в поток стандартного ввода процесса, 
связанного с терминалом.
4. Буфер очищается.

Обсудим дополнительно два вопроса:
1. Как именно реализовано стирания ввода? Например, по клавише Backspace.  
2. Как работает возврат каретки (символ '\r')?  

Ответить на эти вопросы достаточно легко, зная, что ввод буферизируется в скрытом буфере. 
Как оказалось, кстати, его стандартный размер 4096 символов.  

В случае стирания ввода, программа термина, перехватает определенные символы, такие как: 
^? (Backspace), ^H (Ctrl+H). Обладая буфером, она легко может удалить последний в нем символ. 
Также стоит отметить, что упомянутые символы не помещаются в этом буфере, а значит не могут быть 
получены самим выполняющимся процессом. 

Что же касается возврата каретки, то для начала стоит обсудить, откуда он вообще взялся. 
Как говорится, в стародавние времена специально обученные девушки - машинистки - печатали текст 
на бумаге на печатных машинках. Чтобы продолжить печать с новой строчки, они делали 2 действия: 
возвращали каретку и переводили ее на новую строку. И так получилось, что этот символ перешел в ЭВМ. 
Опять-таки обладая буфером строки, реализовать возврат каретки как переставновку указателя на конец 
буфера в его начало несложно.  

Теперь опишем поведение терминала, которые мы хотим иметь:  
1. Нажатие клавиши  
2. Код символа отправляется в поток стандартного ввода процесса.  

То есть, как уже говорилось ранее, мы вычеркиваем из этой схемы буфер строки. Отсюда возникает 
неприятное следствие: раз код символа моментально отправляется процессу, то реализовать стирание 
ввода на уровне термина невозможно. Поэтому об обработке, по крайней мере, символа ^? (Backspace) 
разработчику придется самостоятельно. Что же касается возврата каретки, опытным путем установлено 
что обработка этого символа осуществляется терминала ровно так же, как и до вычеркивания буфера. 
Объяснить это можно только тем, что у программы имеется буфер не только входной строки, но и 
выходной строки. И возврат каретки продолжает работать с буфером выходной строки и, вообще говоря, 
только с ним и работает.  

## Практическое, в кавычках, применение  

Честно говоря, практического смысла в этом мало :) Однако можно поиграться с тем фактом, что ввод 
поступает процессу минуя внутренний буфер термина. Поставим такую задачу:  

Программа должна наблюдать за вводом пользователя и при наступление определенных условий вмешиваться 
в него, стирая вводимую строчку с окна терминала и выводя за место него свой собственный текст.  

Для реализации этого нам понадобится 2 шага:  
1. Отключить буферизацию.  
2. Написать саму программу.  

Чтобы отключить буферизацию, можно воспользоваться стандартной утилитой stty, которая может изменять 
настройки терминала. Нужный нам параметр называется "icanon", в документации к stty он трактуется 
как канонический и неканонический режимы работы термина. В каноническом используется буферизация.  

Что ж, нам требуется прописать такую команду до запуска команды:  

stty -icanon  

Теперь ввод действительно будет сразу попадать нашему процессу. Однако появляются два момента:  
1. Не работает Backspace (по причинам упомянутым ранее), его нам нужно реализовать программно.  
2. Если пользователь будет безостановочно жмякать по клавиатуре, его ввод визуально помешает 
нам реализовать вмешательство.  

С первой проблемой все просто - используем внутренний буфер ввода нашей программы и при попадании 
туда символа ^? (код 127), удаляем его и предыдущий за ним из буфера.  

Что же касается второй - потребуются некоторые дополнительные усилия. Неплохим решением будет отключить 
так называемое эхо терминала. Эхо терминала - это отображение вводимых символов на терминале. 
Само собой отключать нам его хотелось бы не навсегда - пользователь просто не будет видеть вводимый 
текст, что за чушь! - а в определенный момент. Сделать это можно при помощи утилиты stty:

1. Отключим эхо терминала - stty -echo
2. Когда нам это нужно, процесс будет сам осуществлять эхо - выводить каждый вводимый символ в 
поток стандартного вывода.  
3. Когда эхо нам будет мешать, процесс не будет выводить символы, однако символы по-прежнему будут 
поступать во внутренний буфер процесса.  

## Реализация  

Приведу краткое описание классов, жаба программы, которая реализует поставленную задачу.  

class App - главный класс, конфигурирующий нашу программу и запускающий ее.  

class Joker - класс, управляющий логикой программы. Содержит бесконечный цикл, в рамках которого 
процесс ожидает ввода пользователя.  

class TrickyReader - наш собственный reader, реализующий посимвольное буферизованное чтение. Кроме 
того умеет обрабатывать Backspace.  

class InteractiveWriter - наш собственный writer, реализующий "интерактивный" вывод данных на экран. 
Под интерактивностью подразумевается эффект печати, реализумый при помощи задержки потока исполнения, 
кроме того данный класс умеет стирать текущую строку на экране.  

class Stty - статические методы для вызова утилиты stty (чтобы вы, дорогой читатель, сами не вводили 
команды перед запуском программы).  

interface WizardCondition - интерфейс, определяющий классы-условия, которые реализуют единственный 
метод boolean handle(String buffer). Этот метод возвращает true, если в буфере содержится строка, при 
которой нужно осуществить вмешательство в вод пользователя.  

interface BufferWizard - интерфейс, определяющий классы-"волшебники", которые подменяют содержимое 
буфера на что-то другое.  

Joker реализован таким образом, что в него внедряется через конструктор единственный экземпляр 
BufferWizard-а, который будет "творить магию" при каждом из указанных WizardCondition-ах (добавить можно 
через метод add).

Таким образом, если вы хотите поиграться с данным проектом, вам необходимо:

1. Клонировать репозиторий.  
2. Написать свои собственные реализации WizardCondition и BufferWizard.  
3. Изменить App в соответствии с вашими предпочтениями (внедрить в Joker другой BufferWizard и добавить 
другие WizardCondition-ы через метод add).  
4. Из корневой директории проекта выполнить команду:  

Linux: ./gradlew build  
Windows: gradlew build  

5. Перейти в директорию build/libs и запустить исполняемый жабник, который там лежит.  
6. Осуществляйте ввод только в одну строчку, автор не исследовал поведение программы при нажатии 
клавиши enter.  

Всем добра и плодотворных ночного кодинга!
